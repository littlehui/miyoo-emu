<html>
	
<head>
	<title>Идеи</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="generator" content="HelpNDoc Personal Edition 3.9.1.648">
	<link type="text/css" rel="stylesheet" media="all" href="css/reset.css" />
	<link type="text/css" rel="stylesheet" media="all" href="css/base.css" />
	<link type="text/css" rel="stylesheet" media="all" href="css/hnd.css" />
	<!--[if lte IE 8]>
		<link type="text/css" rel="stylesheet" media="all" href="css/ielte8.css" />
	<![endif]-->
	<style type="text/css">
		#topic_header
		{
			background-color: #EFEFEF;
		}
	</style>
	<script type="text/javascript" src="js/jquery.min.js"></script>
	<script type="text/javascript" src="js/hnd.js"></script>
	<script type="text/javascript">
		$(document).ready(function()
		{
			if (top.frames.length == 0)
			{
				var sTopicUrl = top.location.href.substring(top.location.href.lastIndexOf("/") + 1, top.location.href.length);
				top.location.href = "index.html?" + sTopicUrl;
			}
			else if (top && top.FrameTOC && top.FrameTOC.SelectTocItem)
			{
				top.FrameTOC.SelectTocItem("Ideas");
			}
		});
	</script>
</head>

<body>

	<div id="topic_header">
			<div id="topic_header_content">
				<h1>Идеи</h1>
				
				<div id="topic_breadcrumb">
					<a href="TASEditorInside.html">TAS Editor изнутри</a> &rsaquo;&rsaquo; </div>
				</div>
			<div id="topic_header_nav">
				<a href="TASEditorInside.html"><img src="img/arrow_up.png" alt="Parent"/></a>
				
				<a href="TASEditorInside.html"><img src="img/arrow_left.png" alt="Previous"/></a>
				
				<a href="Implementation.html"><img src="img/arrow_right.png" alt="Next"/></a>
				
				</div>
			<div class="clear"></div>
		</div>
	<div id="topic_content">
		
<p></p>
<p><span class="rvts20">Идеи</span></p>
<p class="rvps2"><span class="rvts6"><br/></span></p>
<p class="rvps2"><span class="rvts6"><br/></span></p>
<p class="rvps10"><span class="rvts22">Тасэдитор объединяет множество экспериментальных идей в единую систему. Многие из этих идей возникли очень давно (см. темы на форуме в духе "</span><a class="rvts28" href="http://tasvideos.org/forum/viewtopic.php?t=4559" target="_blank">инструмент мечты</a><span class="rvts22">" и т.д.), но понадобилось немалое время, чтобы реализовать их в рамках непротиворечивой системы.</span></p>
<p class="rvps10"><span class="rvts22">Основообразующей идеей Тасэдитора является интерфейс Piano Roll, позволяющий взаимодействовать с мувиком в интуитивно понятной форме. </span><span class="rvts22">Первые упоминания о необходимости создания инструмента для ТАСинга на основе Piano Roll звучали ещё в </span><a class="rvts28" href="http://tasvideos.org/forum/viewtopic.php?p=38496#38496" target="_blank">2005 году</a><span class="rvts22">, возможно, даже ранее. П</span><span class="rvts22">рототип под названием TASEdit был создан в 2008 году. Окончательное видение Тасэдитора сформировалось в сентябре 2011 года и дорабатывалось по ходу разработки вплоть до лета 2012. Помимо реализованных в</span><span class="rvts22"> это время</span><span class="rvts22"> идей,</span><span class="rvts22"> было придумано множество перспективных, но второстепенных или сложно реализуемых идей, которые было решено отложить на будущее.</span></p>
<p class="rvps21"><span class="rvts22"><br/></span></p>
<div class="rvps21"><table width="600" border="1" cellpadding="0" cellspacing="0" style="border-color: #000000; border-style: solid;">
<tr valign="top">
<td style="border-color: #000000; border-style: solid; background-color: #0000ff; width: 50%;"><p class="rvps5"><a class="rvts78" href="Ideas.html#ImplementedIdeas">Реализовано в 1.0</a></p>
</td>
<td style="border-color: #000000; border-style: solid; background-color: #0000ff; width: 50%;"><p class="rvps5"><a class="rvts78" href="Ideas.html#PlannedIdeas">Запланировано на 2.0</a></p>
</td>
</tr>
<tr valign="top">
<td style="border-color: #000000; border-style: solid; width: 50%;"><p class="rvps18"><a class="rvts63" href="Ideas.html#PianoRoll">Piano Roll</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#Selection">Выделение</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#Markers">Маркеры</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#HotChanges">Горячие Правки</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#Greenzone">Гринзона</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#Playback">Проигрыватель</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#GreenArrow">Зелёная стрелка</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#AutoRestoring">Автовосстановление прошлой позиции</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#Recorder">Мультитрекинг-рекордер</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#Lua">Lua-автоматизация</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#BookmarksBranches">Закладки и ответвления</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#PopupWindows">Всплывающие окна</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#HistoryLog">Журнал Истории</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#RerecordsCounter">Счётчик перезаписей</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#Modifiers">Система клавиш-модификаторов</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#Patterns">Шаблоны</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#CrossingGaps">Пересечение промежутков</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#SaveCompact">Компактное сохранение</a></p>
<p class="rvps18"><a class="rvts63" href="Ideas.html#Autosave">Автосохранение</a></p>
</td>
<td style="border-color: #000000; border-style: solid; width: 50%;"><p class="rvps5"><a class="rvts77" href="Ideas.html#OutputLog">Журнал Вывода</a></p>
<p class="rvps5"><a class="rvts77" href="Ideas.html#Minimap">Миникарта</a></p>
<p class="rvps5"><a class="rvts77" href="Ideas.html#VirtualJoypad">Виртуальный Джойстик</a></p>
<p class="rvps5"><a class="rvts77" href="Ideas.html#BetterSelection">Усовершенствование Выделения</a></p>
<p class="rvps5"><a class="rvts77" href="Ideas.html#BetterColumns">Гибкая настройка колонок</a></p>
<p class="rvps5"><a class="rvts77" href="Ideas.html#RerecordsHeatmap">Теплокарта перезаписей</a></p>
<p class="rvps5"><a class="rvts77" href="Ideas.html#Etc">Прочие мелочи</a></p>
<p class="rvps5"><a class="rvts77" href="Ideas.html#OtherPlatforms">Поддержка платформ, отличных от NES</a></p>
</td>
</tr>
</table>
</div>
<p class="rvps21"><span class="rvts22"><br/></span></p>
<hr style="height: 1px; color : #000000;  background-color : #000000; border-width : 0px;"/>
<p class="rvps2"><a name="ImplementedIdeas"></a>
<span class="rvts37"><br/></span></p>
<p class="rvps10"><span class="rvts76">Реализованные идеи</span></p>
<p class="rvps10"><a name="PianoRoll"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Piano Roll</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Основа Тасэдитора, вокруг этой идеи и были сформированы все остальные.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Представляет собой значительно переработанный компонент Список (ListView) или Таблица (GridView). Столбцы Списка соответствуют кнопкам Ввода, строки Списка соответствуют кадрам мувика. Количество строк Списка регулярно автоматически обновляется, чтобы соответствовать количеству кадров текущего мувика. Строки нумеруются сверху вниз от нуля. Номер строки равен номеру кадра, с которым ассоциируется эта строка. Количество столбцов зависит от типа мувика (от количества джойстиков и количества кнопок).</span></li>
<li class="rvps10"><span class="rvts22">Слева перед столбцами Ввода располагаются два дополнительных столбца. Самый первый столбец (шириной ~17 пикселей) отвечает за отображение иконок и за управление Курсором Проигрывателя. Текущее положение Курсора Проигрывателя отображается иконкой в виде голубой стрелки. При щелчке левой кнопкой по этому столбцу Курсор Проигрывателя посылается на соответствующий кадр, и начинается перетаскивание Курсора, пока не будет отпущена левая кнопка.</span></li>
<li class="rvps10"><span class="rvts22">Второй столбец (шириной 75 пикселей) отвечает за отображение номеров кадров, отображение Маркеров, управление Выделением и управление Маркерами. При одинарном щелчке левой кнопкой по этому столбцу изменяется Выделение (и можно растягивать Выделение перетаскиванием). При двойном щелчке на этом кадре ставится Маркер, и начинается перетаскивание этого Маркера, пока не будет отпущена левая кнопка.</span></li>
<li class="rvps10"><span class="rvts22">В Заголовке Списка отображаются названия столбцов. Самый первый столбец (столбец иконок) не имеет названия, второй столбец назван "Frame#" (номер кадра), остальные столбцы обозначены символом соответствующей кнопки джойстика. Этот же символ отображается в ячейках данного столбца на тех строках, где данная кнопка является нажатой. По ячейкам Заголовка Списка можно щёлкать, изменяя Ввод соответствующей кнопки в выделенных кадрах. А при щелчке по "Frame#" изменяются Маркеры в выделенных кадрах.</span></li>
<li class="rvps10"><span class="rvts22">Кроме того, Заголовок служит индикатором зажатых кнопок джойстика. А при Записи Ввода в Заголовке вспыхивают символы, кнопки которых были только что записаны в мувик.</span></li>
<li class="rvps10"><span class="rvts22">Столбцы Ввода отображают состояние каждой кнопки джойстика для каждого кадра мувика. Чтобы узнать состояние кнопки, нужно визуально найти пересечение строки требуемого кадра и столбца требуемой кнопки. Если в этой ячейке находится символ кнопки, то кнопка в данном кадре нажата. Если в этой ячейке пустота или прочерк, то кнопка отпущена. Щелчком левой кнопкой мыши по любой ячейке Ввода можно инвертировать состояние соответствующей кнопки. &nbsp;Кроме того, если зажать левую кнопку мыши, можно рисовать или стирать Ввод в соседних кадрах, перемещая курсор мыши выше или ниже.</span></li>
<li class="rvps10"><span class="rvts22">Строки Piano Roll раскрашиваются разными цветами в пастельных тонах, чтобы на их фоне были чётко видны номера кадров (отображаемые чёрным цветом) и символы кнопочных нажатий (отображаемые тёмными цветами). По цвету строки Piano Roll пользователь может сразу определить, находится ли данный кадр мувика в Гринзоне, проявляется ли лаг в данном кадре, является ли данный кадр текущим (отображаемым в окне эмулятора в данный момент), является ли данный кадр выделенным. Также дополнительными цветами можно акцентировать внимание пользователя на определённых кадрах, например, на кадре окончания добегания (мигающий голубой цвет) или на ключевом кадре отката (фиолетовый цвет). Кроме того, по цвету фона ячеек с номерами кадров пользователь может определить наличие Маркера на этом кадре (жёлтый цвет).</span></li>
<li class="rvps10"><span class="rvts22">Расцветка ячеек Piano Roll зависит не только от строки, но и от столбца (хоть и в меньшей мере). Столбец иконок всегда отображается белым цветом. Стобец номеров кадров отображается бледным оттенком текущего цвета строки. Столбцы кнопок первого (а также третьего) джойстика отображаются нормальным оттенком текущего цвета строки (зелёным, красным, голубым и т.д.), а столбцы кнопок второго (а также четвёртого) джойстика отображаются немного затемнённым оттенком текущего цвета строки.</span></li>
<li class="rvps10"><span class="rvts22">Видимая область Piano Roll может скроллироваться колесом мыши или с помощью скроллбаров, а также с помощью множества других </span><a class="rvts28" href="Navigation.html#scrolling-piano-roll">способов навигации</a><span class="rvts22">. Многообразие способов призвано ускорить навигацию к любому желаемому участку мувика, так как в видимой области отображается лишь ограниченное количество строк. Это количество зависит от текущей высоты Piano Roll в пикселах, которая зависит от текущей высоты окна TAS Editor.</span></li>
</ul>
<p class="rvps10"><a name="Selection"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Выделение</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Как и в любом другом редакторе, &nbsp;в Тасэдиторе Выделение служит для применения операций к множеству кадров одновременно. Кроме того, здесь Выделение служит в качестве указателя (курсора) на место последнего редактирования Ввода.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Выделение хранится в виде списка номеров кадров, считающихся выделенными.</span></li>
<li class="rvps10"><span class="rvts22">Тасэдитор также хранит в памяти Журнал Выделений в виде массива списков. Размер массива равен размеру Журнала Истории. Можно возвращаться к предыдущим выделениям с помощью </span><span class="rvts34">Ctrl + Q</span><span class="rvts22"> и </span><span class="rvts34">Ctrl + W</span><span class="rvts22">. Это полезно для отслеживания истории недавних щелчков по Piano Roll.</span></li>
<li class="rvps10"><span class="rvts22">Для управления Выделением служит столбец Piano Roll с номерами кадров. Если после щелчка по номеру кадра зажать левую кнопку, можно растягивать Выделение на соседние кадры. Если зажать клавишу </span><span class="rvts34">Ctrl</span><span class="rvts22"> перед щелчком по номеру кадра, ранее выделенные кадры останутся выделенными, а при простом щелчке по номеру кадра или Ввода текущее Выделение уходит в историю Выделений, и вместо него создаётся новое Выделение, состоящее из одного кадра (по которому был сделан щелчок). Если зажать клавишу </span><span class="rvts34">Shift </span><span class="rvts22">перед щелчком по номеру кадра, выделятся все кадры от начала старого Выделения до кадра щелчка. Если зажать </span><span class="rvts34">Alt </span><span class="rvts22">перед щелчком по номеру кадра, создастся Выделение по шаблону. Также Выделение меняется и при щелчке по ячейкам Ввода, но только когда не зажаты клавиши модификаторы,</span></li>
<li class="rvps10"><span class="rvts22">Самый верхний выделенный кадр называется Курсором Выделения. Если не выделено ни одного кадра, подразумевается, что Курсор Выделения указывает на кадр с номером -1. Это нужно для некоторых ситуаций, например, при отсутствии Выделения в нижнем текстовом поле отображается Заметка нулевого Маркера.</span></li>
<li class="rvps10"><span class="rvts22">Журнал Выделений (в том числе текущее Выделение) сохраняется и загружается из файла проекта. При изменении настройки "max undo levels" происходит соответствующее изменение размера Журнала Выделений.</span></li>
<li class="rvps10"><span class="rvts22">При вставке и удалении кадров текущее Выделение смещается на соответственное количество строк вниз или вверх, чтобы оставаться на тех же позициях (относительно Ввода).</span></li>
<li class="rvps10"><span class="rvts22">Текущее Выделение можно сдвигать (</span><span class="rvts34">Ctrl + Вверх</span><span class="rvts22"> / </span><span class="rvts34">Ctrl + Вниз</span><span class="rvts22"> / </span><span class="rvts34">Ctrl + Home</span><span class="rvts22"> / </span><span class="rvts34">Ctrl + End</span><span class="rvts22">). Если часть Выделения выходит за рамки Piano Roll, эта часть исчезает. То есть пользователь не может выделить кадры за пределами текущего мувика.</span></li>
<li class="rvps10"><span class="rvts22">Курсором Выделения можно осуществлять прыжки по Маркерам (</span><span class="rvts34">Ctrl + Page Up</span><span class="rvts22"> / </span><span class="rvts34">Ctrl + Page Down</span><span class="rvts22">), при этом текущее Выделение уходит в Историю, а вместо него появляется один выделенный кадр на месте следующего Маркера.</span></li>
<li class="rvps10"><span class="rvts22">Видимая область Piano Roll всегда следует за Выделением. При этом, если Выделение не помещается целиком на экране, Piano Roll скроллируется таким образом, чтобы Курсор Выделения был в середине, а если Выделение помещается – отображает все выделенные кадры.</span></li>
<li class="rvps10"><span class="rvts22">В нижнем текстовом поле отображается текст Заметки маркера, на участке которого находится Курсор Выделения. Этот текст обновляется при каждом изменении Выделения, а также при изменении текущих Маркеров.</span></li>
<li class="rvps10"><span class="rvts22">При нажатии </span><span class="rvts34">Ctrl + A</span><span class="rvts22"> текущее Выделение уходит в Историю, вместо него становятся выделенными все кадры, начиная с Маркера, на участке которого был Курсор Выделения, заканчивая следующим Маркером (не включая этот Маркер). Таким образом выделяется весь участок текущего Маркера. При следующем нажатии </span><span class="rvts34">Ctrl + A</span><span class="rvts22"> Выделение изменится на набор кадров между Маркерами, не включая верхний и нижний Маркеры. При третьем </span><span class="rvts34">Ctrl + A</span><span class="rvts22"> Выделение изменится на набор кадров между Маркерами, не включая верхний, но включая нижний Маркер. Наконец, при четвёртом нажатии </span><span class="rvts34">Ctrl + A</span><span class="rvts22"> Выделение изменится на набор кадров между Маркерами, включающий оба Маркера. При дальнейших нажатиях </span><span class="rvts34">Ctrl + A</span><span class="rvts22"> будет повторение предыдущих вариантов выделения.</span></li>
</ul>
<p class="rvps10"><a name="Markers"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Маркеры</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">При редактировании больших мувиков пользователю может понадобиться установка отметок на некоторые строки Piano Roll, чтобы эти строки визуально отличались от соседних. После ряда усовершенствований эта простая идея вылилась в многогранную фичу.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Любой кадр мувика может быть отмечен. При желании пользователь может даже отметить Маркерами все кадры мувика. Кроме того, пользователь может оставить отметку, например, на кадре 1200, а затем сделать усечение Ввода после кадра 1000, оставив отвязанный от Ввода Маркер за пределами мувика. Этот Маркер будет оставаться в проекте. Чтобы увидеть его, нужно опять проэмулировать игру до кадра 1200, чтобы в Piano Roll отразилась строка с этим Маркером.</span></li>
<li class="rvps10"><span class="rvts22">Неотмеченные строки Piano Roll отображаются обычными цветами, а в отмеченных строках ячейка с номером кадра имеет жёлтый цвет фона. Этот цвет выбран, так как Маркеры призваны обращать на себя внимание пользователя. Также номера отмеченных кадров отображаются особым шрифтом, чтобы о наличии Маркера можно было догадаться, даже когда жёлтый фон ячейки загораживается синим цветом Выделения.</span></li>
<li class="rvps10"><span class="rvts22">Маркеры могут быть привязаны к Вводу (тогда они отображаются бледно-жёлтым цветом), а могут быть отвязанными (отображаются более насыщенным жёлтым цветом). Когда Маркеры привязаны, на них действуют все операции по смещению Ввода вверх/вниз, а также усечению Ввода.</span></li>
<li class="rvps10"><span class="rvts22">Маркер ставится двойным щелчком левой кнопкой мыши по номеру желаемого кадра. Если сделать двойной щелчок по уже установленному Маркеру, начинается его перетаскивание (до момента отпускания левой кнопки). Так можно перенести Маркер на другой кадр или удалить, перенеся за рамки Piano Roll. При перетаскивании под курсором мыши висит образ Маркера в виде жёлтого прямоугольника с номером кадра, с которого был снят этот Маркер. Чтобы отменить перетаскивание, нужно опустить Маркер либо на ту же самую ячейку с номером кадра, либо на любую ячейку Ввода.</span></li>
<li class="rvps10"><span class="rvts22">Также Маркеры можно устанавливать и удалять с помощью контекстного меню или с помощью щелчка по надписи "Frame#".</span></li>
<li class="rvps10"><span class="rvts22">Обычно Маркеры ставятся относительно далеко друг от друга, и между ними находятся промежутки из неотмеченных кадров. Поэтому Маркеры можно воспринимать не только как цветовое выделение особенных кадров, но и как пограничные отметки для участков мувика. Для стандартизации принята следующая терминология: каждому Маркеру соответствует участок кадров мувика, начинающийся с отмеченного кадра и заканчивающийся последним неотмеченным кадром. Например, если в мувике на кадрах 10 и 20 стоят Маркеры, то участком первого маркера является регион кадров с 10-го по 19-й, а участком второго маркера – регион с 20-го по последний кадр мувика.</span></li>
<li class="rvps10"><span class="rvts22">Промежутки между Маркерами можно пересекать прыжками от текущего к следующему (или предыдущему). Это позволяет в ряде случаев ускорить навигацию по мувику.</span></li>
<li class="rvps10"><span class="rvts22">С помощью функции </span><span class="rvts26">Select between Markers</span><span class="rvts22"> (</span><span class="rvts34">Ctrl + A</span><span class="rvts22">) можно быстро выделить все кадры на участке текущего Маркера. Таким образом Маркеры позволяют ускорить не только навигацию, но и редактирование.</span></li>
<li class="rvps10"><span class="rvts22">Каждый Маркер имеет свою текстовую Заметку. При создании она пустая. Пользователь может просматривать и редактировать Заметку с помощью любого из двух имеющихся текстовых полей. В верхнем текстовом поле отображается Заметка Маркера, на участке которого находится Курсор Проигрывателя. В нижнем текстовом поле отображается Заметка Маркера, на участке которого находится Курсор Выделения. Таким образом, чтобы отредактировать желаемую Заметку, нужно сначала поставить один из курсоров на её Маркер или на кадр под Маркером. В теории это звучит неудобно, но рабочий процесс в Тасэдиторе организован таким образом, что под нужными Маркерами обязательно стоит какой-нибудь курсор.</span></li>
<li class="rvps10"><span class="rvts22">Объём Заметки ограничен сотней символов, так как Заметки предназначены не для хранения длинных текстов, а для коротких комментариев, тегов и тому подобных записок на салфетках. В крайнем случае можно разместить несколько Маркеров подряд, разбив длинный текст на несколько соседствующих Заметок.</span></li>
<li class="rvps10"><span class="rvts22">По тексту Заметок можно осуществлять обычный поиск (Find Note) и нечёткий поиск (Similar/More). Подробнее см. </span><a class="rvts28" href="AdvancedFeatures.html#UsingMarkers">Продвинутые возможности</a><span class="rvts22">.</span></li>
<li class="rvps10"><span class="rvts22">Маркеры сохраняются и восстанавливаются из ответвлений Закладок вместе с Вводом. Каждая операция с Маркерами заносится в Журнал Истории аналогично операциям с Вводом. В файле проекта текущее состояние Маркеров сохраняется сразу после данных о Вводе.</span></li>
</ul>
<p class="rvps10"><a name="HotChanges"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Горячие Правки</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Тасэдитор раскрашивает текстовые символы в ячейках Ввода разными цветами, в зависимости от давности редактирования каждой ячейки. Подробнее см. </span><a class="rvts28" href="PianoRoll.html#HotChanges">Интерфейс программы</a><span class="rvts22"> и </span><a class="rvts28" href="ProgramCustomization.html#EnableHotChanges">Настройка программы</a><span class="rvts22">.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">В памяти хранятся значения сразу всех ячеек Ввода, даже несмотря на то, что большинство из них имеет нулевой уровень горячести. Это необходимо для тех редких случаев, когда массово изменяются почти все ячейки мувика (например, при операциях </span><a class="rvts28" href="Operations.html#Import">Import</a><span class="rvts22"> или </span><a class="rvts28" href="Operations.html#Paste">Paste</a><span class="rvts22">). Массив Горячих Правок занимает много места в оперативной памяти, но хорошо сжимается и занимает мало места на диске.</span></li>
<li class="rvps10"><span class="rvts22">16 градаций цвета, чтобы в одном байте умещалась информация о горячести двух ячеек. Кроме того, добавлять ещё больше градаций нет смысла, так как человеческий глаз будет хуже различать их, а ценность Горячих Правок именно в возможности быстрой визуальной оценки Ввода, не требующей длительного обдумывания.</span></li>
<li class="rvps10"><span class="rvts22">Состояние текущей карты Горячих Правок меняется только при добавлении нового пункта в Журнал истории и при откатах Истории.</span></li>
</ul>
<ul style="text-indent: 30px; margin-left: 40px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">при редактировании Ввода все старые ячейки теряют один уровень горячести, а изменённые ячейки приобретают максимальный уровень</span></li>
<li class="rvps10"><span class="rvts22">при удалении кадров старые ячейки теряют один уровень горячести</span></li>
<li class="rvps10"><span class="rvts22">при вставке кадров старые ячейки теряют один уровень горячести, а все ячейки вставленных кадров приобретают максимальный уровень</span></li>
<li class="rvps10"><span class="rvts22">при изменении Маркеров или Закладок, а также при усечении мувика Горячие Правки не меняются</span></li>
<li class="rvps10"><span class="rvts22">при прыжке на Закладку во времени текущие Горячие Правки замещаются Горячими Правками из ответвления Закладки</span></li>
<li class="rvps10"><span class="rvts22">при импорте Ввода старые ячейки обнуляют уровень горячести, а изменённые ячейки приобретают максимальный уровень</span></li>
</ul>
<p class="rvps10"><a name="Greenzone"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Гринзона</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Так как интерфейс Piano Roll предоставляет пользователю почти мгновенный доступ к изменению Ввода на любом кадре мувика, желательно также предоставить быстрый доступ к просмотру состояния игры на любом кадре мувика. Это реализуется с помощью кеширования данных о всех проэмулированных состояниях игры.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Гринзона представляет собой массив информации о Выводе игры на начало каждого кадра. То есть в ячейке с номером 0 хранится состояние игры до начала эмуляции, в ячейке 1 – состояние игры перед началом эмуляции второго кадра (кадра с номером 000001) и т.д. Помимо сэйвов Гринзона хранит Журнал лага, соответствующий Вводу текущего мувика. Также теоретически возможно хранение и другой информации.</span></li>
<li class="rvps10"><span class="rvts22">Гринзона начинается с нулевого кадра и имеет нижнюю границу (голову) &nbsp;– номер кадра, начиная с которого в Гринзоне отсутствует информация о дальнейших состояниях игры (однако для них может присутствовать информация в Журнале лага).</span></li>
<li class="rvps10"><span class="rvts22">Данные в Гринзону собираются в начале каждого кадра (перед эмуляцией) по следующему принципу: если в массиве Гринзоны ячейка с номером, равным текущему кадру, пустует, или же позиция головы Гринзоны меньше номера текущего кадра, то ячейка массива заполняется информацией о текущем состоянии игры (из эмулятора), а голова Гринзоны при необходимости перемещается вперёд.</span></li>
<li class="rvps10"><span class="rvts22">Для экономии памяти Гринзона периодически разреживается, удаляя сэйвы (но не трогая Журнал лага) некоторых ранних кадров, от которых Курсор Проигрывателя ушёл достаточно далеко. </span><span class="rvts22">Подробнее см. </span><a class="rvts28" href="ProgramCustomization.html#SetGreenzonecapacity">Настройка программы</a><span class="rvts22">.</span></li>
<li class="rvps10"><span class="rvts22">Вся Гринзона вместе с Журналом лага сохраняется и загружается из файла проекта. После загрузки проекта Тасэдитор восстанавливает состояние Курсора Проигрывателя с помощью Гринзоны.</span></li>
<li class="rvps10"><span class="rvts22">При любом изменении Ввода текущего мувика из Гринзоны удаляется информация о кадрах, идущих после первого изменённого кадра (не включая этот кадр). Это реализуется с помощью уменьшения позиции головы Гринзоны и удаления устаревшей информации из массива сэйвов (без освобождения памяти, так как на место старых сэйвов вскоре будут записаны новые данные примерно того же размера).</span></li>
<li class="rvps10"><span class="rvts22">Курсор Проигрывателя всегда обязан находиться внутри Гринзоны, чтобы на экране FCEUX никогда не отображалось неактуальное состояние игры. Так что из-за усечения Гринзоны вполне может переместиться и Курсор Проигрывателя.</span></li>
<li class="rvps10"><span class="rvts22">При создании Закладки в неё копируется Журнал лага и сэйв соответствующего кадра Гринзоны. При загрузке этой Закладки сначала усекается Гринзона (из-за изменения Ввода), но потом из Закладки в соответствующую ячейку Гринзоны восстанавливается сэйв и часть Журнала лага, и при необходимости передвигается позиция головы Гринзоны.</span></li>
<li class="rvps10"><span class="rvts22">Информация из Гринзоны используется при раскрашивании строк Piano Roll и Списка Закладок. Информация из Журнала лага отображается не только для кадров, содержащихся в Гринзоне, но и для отсутствующих в ней кадров. Каждый элемент Журнала лага может иметь одно из трёх значений: есть лаг, нет лага, неизвестно.</span></li>
<li class="rvps10"><span class="rvts22">Информация в Журнал лага собирается одновременно со сбором текущего состояния игры в Гринзону. То есть перед началом эмуляции текущего кадра. В этот момент эмулятор обладает информацией о лаге предыдущего кадра, поэтому на кадре с номером 000020 данные о лаге сохраняются в ячейку 19. Также именно в этот момент может сработать операция </span><a class="rvts28" href="Operations.html#AdjustLag">AdjustLag</a><span class="rvts22">, которая сдвигает весь Ввод в последующих кадрах мувика вверх или вниз. Ввод сдвигается вверх, если в Журнале лага на прошлом кадре был лаг, а теперь его не стало. Ввод сдвигается вниз, если в Журнале лага на прошлом кадре не было лага, а теперь он есть. Вместе с Вводом аналогично сдвигается и все последующие ячейки Журнала лага, чтобы красные строки Piano Roll по-прежнему соответствовали сдвинувшимся пропускам во Вводе.</span></li>
</ul>
<p class="rvps10"><a name="Playback"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Проигрыватель</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Проигрыватель – это собрание всех функций по просмотру Вывода (состояния игры).</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Главный атрибут Проигрывателя – текущий проигрываемый кадр мувика, скриншот этого кадра отображается в окне эмулятора в данный момент времени. Этому кадру соответствует голубая строка в Piano Roll, которая носит название Курсор Проигрывателя. Так как Курсор Проигрывателя привязан к состоянию эмулируемой игры, можно использовать его не только в качестве индикатора, но и в качестве управляющего элемента. Чтобы увидеть на экране FCEUX события интересующего кадра, нужно передвинуть Курсор Проигрывателя на строку с номером этого кадра. Для этого есть </span><a class="rvts28" href="Navigation.html#playback-cursor">множество способов</a><span class="rvts22">.</span></li>
<li class="rvps10"><span class="rvts22">Когда пользователь посылает Курсор Проигрывателя на кадр, содержащийся в Гринзоне, состояние эмулируемой игры восстанавливается из соответствующего сэйва. Так как при этом не было никакой эмуляции, Тасэдитор имитирует события "frame boundary" и "frame begin"/"frame end", чтобы сработали соответствующие функции Lua.</span></li>
<li class="rvps10"><span class="rvts22">Когда пользователь посылает Курсор Проигрывателя на кадр, не содержащийся в Гринзоне, Тасэдитор восстанавливает состояние игры на ближайший предшествующий кадр, для которого имеется сэйв Гринзоны, а затем запускает добегание к желаемому кадру. Добегание – это эмуляция, которая автоматически останавливается при достижении целевого кадра. Во время добегания на целевом кадре в Piano Roll мигает копия голубого курсора.</span></li>
<li class="rvps10"><span class="rvts22">Добегание базируется на следующем принципе. Так как эмулятор обеспечивает детерминизм, состояние игры на любом кадре можно гарантированно получить, используя базовое состояние игры (состояние на начало мувика) и Ввод из мувика. Более того, можно получить требуемое состояние, используя состояние на любой предыдущий кадр (сэйв из Гринзоны) и Ввод из мувика.</span></li>
<li class="rvps10"><span class="rvts22">Процесс добегания отображается на прогрессбаре, чтобы в случае длительного добегания пользователь мог оценить оставшееся время ожидания. Когда добегания нет, прогрессбар полностью заполнен во время паузы и пуст во время эмуляции.</span></li>
<li class="rvps10"><span class="rvts22">Добегание может осуществляться на максимально возможной скорости эмуляции. В этом случае для относительно небольших участков добегание будет завершено практически мгновенно.</span></li>
<li class="rvps10"><span class="rvts22">Во многих случаях полезно автоматически останавливать эмуляцию на последнем кадре, для которого в мувике есть Ввод. Для этого служит настройка </span><a class="rvts28" href="ProgramCustomization.html#AutopauseattheendofMovie">Autopause at the end of Movie</a><span class="rvts22">. Когда эмулятор стоит на паузе, если Курсор Проигрывателя находится не на последнем кадре мувика, Проигрыватель устанавливает флаг автоматической остановки. И если пользователь отпустит паузу, Проигрыватель автоматически остановится при достижении последнего кадра мувика. Благодаря этому Курсор Проигрывателя при отпущенной паузе не будет убегать за пределы мувика.</span></li>
<li class="rvps10"><span class="rvts22">В большинстве случаев пользователю не требуется автоматически скроллировать Piano Roll к Курсору Проигрывателя во время самопроизвольного передвижения этого курсора. А для тех случаев, когда это всё-таки нужно, служит галочка "Follow cursor".</span></li>
</ul>
<p class="rvps10"><a name="GreenArrow"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Зелёная стрелка</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">При создании спидранов ТАСер пытается обогнать свой рекорд на каждом участке. В большинстве случаев критерием оптимальности является номер</span><span class="rvts37"> кадра, на котором происходит целевое событие участка</span><span class="rvts22">. Для его определения ТАСер перемещает Курсор Проигрывателя, одновременно просматривая экран FCEUX, и останавливает этот ручной поиск в тот момент, когда обнаружено начало интересующего события. Обычно Курсор Проигрывателя так и остаётся на найденном кадре, а ТАСер начинает изменять Ввод на участке (над Курсором Проигрывателя), надеясь улучшить старый подход и получить то же событие на более раннем кадре.</span></p>
<p class="rvps10"><span class="rvts22">Во время изменения Ввода Гринзона усекается, и Курсор Проигрывателя отступает назад. Когда ТАСер считает, что внёс во Ввод достаточно существенные изменения, он начинает проверку Вывода, чтобы определить, на каком кадре начинается целевое событие теперь. Для этого он опять перемещает Курсор Проигрывателя, одновременно просматривая экран FCEUX.</span></p>
<p class="rvps10"><span class="rvts22">Чтобы сделать вывод об улучшении, ТАСеру нужно сравнить старый номер кадра (найденный в прошлый раз) и новый номер, найденный только что. Тасэдитор визуализирует эти данные, чтобы пользователю не требовалось запоминать числа в уме. На новый номер указывает Курсор Проигрывателя, на старый номер указывает зелёная стрелка.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Полное название зелёной стрелки – прошлая (предыдущая) позиция Курсора Проигрывателя.</span></li>
<li class="rvps10"><span class="rvts22">Более универсальной заменой зелёной стрелке служат Маркеры и Закладки, устанавливаемые вручную.</span></li>
<li class="rvps10"><span class="rvts22">Иконка зелёной стрелки отображается в столбце иконок Piano Roll. При рисовании иконок в Piano Roll зелёная стрелка имеет более высокий приоритет над голубой стрелкой (иконкой Курсора Проигрывателя), так как положение голубого курсора можно определить и по другим столбцам.</span></li>
<li class="rvps10"><span class="rvts22">Зелёная стрелка появляется на кадре вместо Курсора Проигрывателя в момент усечения Гринзоны. И она остаётся на этом кадре до тех пор, пока не будет произведена следующая последовательность событий:</span></li>
</ul>
<ol style="text-indent: 30px; margin-left: 40px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">эмуляция хотя бы одного кадра (подразумевается, что пользователь запустил просмотр участка)</span></li>
<li class="rvps10"><span class="rvts22">следующее отступление Курсора Проигрывателя из-за усечения Гринзоны</span></li>
</ol>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Таким образом, зелёная стрелка не меняет своё положение, когда ещё до запуска эмуляции Гринзона усекается повторно (например, ТАСер изменил Ввод на кадре 90, а затем на кадре 80, но зелёная стрелка так и осталась на кадре 100).</span></li>
<li class="rvps10"><span class="rvts22">Также зелёная стрелка не меняет своё положение, когда Гринзона усекается во время добегания, и эмулятор в этот момент не стоит на паузе.</span></li>
<li class="rvps10"><span class="rvts22">Зелёная стрелка не меняет своё положение при операциях </span><a class="rvts28" href="Operations.html#AdjustLag">AdjustLag</a><span class="rvts22">, </span><a class="rvts28" href="Operations.html#Branch">Branch</a><span class="rvts22">, </span><a class="rvts28" href="Operations.html#Record">Record</a><span class="rvts22">.</span></li>
<li class="rvps10"><span class="rvts22">При нажатии средней кнопки мыши запускается добегание к зелёной стрелке, если она находится за пределами Гринзоны. Если же зелёная стрелка находится внутри Гринзоны, это означает, что текущий участок уже был просмотрен до конца, и автоматическая пауза на зелёной стрелке больше не нужна.</span></li>
</ul>
<p class="rvps10"><a name="AutoRestoring"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Автоматическое восстановление прошлой позиции</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">При создании любых ТАСов критерием оптимальности может быть </span><span class="rvts37">состояние игры на одном и том же кадре</span><span class="rvts22">, либо </span><span class="rvts37">ход событий на участке</span><span class="rvts22">. ТАСер просматривает участок и оставляет Курсор Проигрывателя на последнем кадре участка, затем изменяет Ввод на участке и опять просматривает участок, останавливая Курсор Проигрывателя на том же самом кадре. Вывод об улучшении ТАСер делает либо во время просмотра событий участка, либо после остановки эмуляции, оценивая характеристики последнего кадра.</span></p>
<p class="rvps10"><span class="rvts22">Этот процесс можно автоматизировать, автоматически запуская добегание к зелёной стрелке после каждого усечения Гринзоны. Для этого служит галочка "Auto-restore last position".</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Когда галочка установлена, сразу после усечения Гринзоны запускается добегание к последней позиции Курсора Проигрывателя.</span></li>
<li class="rvps10"><span class="rvts22">Если Гринзона была усечена во время добегания, при усечении будет продолжено добегание к целевому кадру. Но если во время усечения Гринзоны добегание стоит на паузе, это добегание отменяется, и будет запущено добегание к зелёной стрелке. Подразумевается, что если ТАСер не дождался окончания добегания, поставил эмулятор на паузу и начал изменять Ввод на участке, то он сосредоточился на подучастке, поэтому дальнейший автоматический просмотр будет запускаться именно для этого подучастка.</span></li>
<li class="rvps10"><span class="rvts22">Автовосстановление не запускается при операциях </span><a class="rvts28" href="Operations.html#AdjustLag">AdjustLag</a><span class="rvts22">, </span><a class="rvts28" href="Operations.html#Branch">Branch</a><span class="rvts22">, </span><a class="rvts28" href="Operations.html#Record">Record</a><span class="rvts22">. При срабатывании операции </span><a class="rvts28" href="Operations.html#AdjustLag">AdjustLag</a><span class="rvts22"> проигрывание мувика не затрагивается.</span></li>
</ul>
<p class="rvps10"><a name="Recorder"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Мультитрекинг-рекордер</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Рекордер – это собрание всех функций по редактированию Ввода на кадре под Курсором Проигрывателя. Рекордер предоставляет ТАСеру второй способ редактирования Ввода – Запись.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Мультитрекинг позволяет ТАСеру в режиме Записи изменять данные только одного выбранного джойстика, оставляя данные других джойстиков на этом же кадре нетронутыми. Подробнее см. </span><a class="rvts28" href="Toolbox.html#multitracking">Панель инструментов</a><span class="rvts22">.</span></li>
<li class="rvps10"><span class="rvts22">Когда включен режим Записи, в начале каждого кадра эмулятор опрашивает виртуальные джойстики и записывает данные в текущий мувик. Затем сразу же передаёт управление Рекордеру.</span></li>
<li class="rvps10"><span class="rvts22">Рекордер:</span></li>
</ul>
<ul style="text-indent: 30px; margin-left: 40px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">использует данные из мувика (данные на кадре Курсора Проигрывателя) в качестве записываемых данных, либо (если идёт Запись по шаблону, и сейчас надо записывать отсутствие нажатий) использует ноль в качестве записываемых данных</span></li>
<li class="rvps10"><span class="rvts22">сравнивает записываемые данные со старыми данными, хранящимися в Журнале Истории</span></li>
<li class="rvps10"><span class="rvts22">накладывает на изменения фильтр, соответствующий выбранному режиму мультитрекинга</span></li>
<li class="rvps10"><span class="rvts22">избирательно объединяет старые данные с новыми, в соответствии с галочкой "Superimpose"</span></li>
<li class="rvps10"><span class="rvts22">сохраняет итоговые изменения в текущий мувик</span></li>
<li class="rvps10"><span class="rvts22">вызывает добавление пункта в Журнал Истории и усечение Гринзоны</span></li>
<li class="rvps10"><span class="rvts22">затем возвращает управление эмулятору</span></li>
</ul>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Эмулятор возвращает данные из текущего мувика в виртуальные джойстики, чтобы использовать эти данные при эмуляции кадра. Также в этот момент эмулятор исполняет записанные команды (сброс и т.д.).</span></li>
<li class="rvps10"><span class="rvts22">В каждом кадре Рекордер получает от эмулятора информацию о зажатых в данный момент кнопках виртуальных джойстиков и подготавливает для Piano Roll информацию о том, какие столбцы в Заголовке Piano Roll должны загораться зелёным светом. Например, если выбрана радиокнопка "2P" и установлена галочка </span><a class="rvts28" href="ProgramCustomization.html#Use1PkeysforallsingleRecordings">Use 1P keys for all single Recordings</a><span class="rvts22">, то при нажатии кнопки </span><span class="rvts32">A</span><span class="rvts22"> на первом джойстике в Заголовке Piano Roll будет загораться столбец "A" второго джойстика. А если в предыдущем кадре кнопка </span><span class="rvts32">A</span><span class="rvts22"> не была зажата, то Рекордер воспринимает это в соответствии с галочкой </span><a class="rvts28" href="ProgramCustomization.html#UseInputkeysforColumnSet">Use Input keys for Column Set</a><span class="rvts22">.</span></li>
</ul>
<p class="rvps10"><a name="Lua"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Lua-автоматизация</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Lua позволяет пользователю расширить возможности Тасэдитора, в частности, предоставляет ТАСеру третий способ редактирования Ввода – автоматическая генерация.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Интерпретатор Lua-функций вызывает соответствующую функцию Тасэдитора не напрямую, а через луа-шлюз Тасэдитора (taseditor_lua).</span></li>
<li class="rvps10"><span class="rvts22">При срабатывании какой-либо функции из библиотеки "taseditor" луа-интерпретатор берёт входные данные из стека, конвертирует их в формат, принимаемый луа-шлюзом Тасэдитора, и передаёт их соответствующей функции луа-шлюза Тасэдитора.</span></li>
<li class="rvps10"><span class="rvts22">Луа-шлюз Тасэдитора вызывает соответствующие функции Тасэдитора и передаёт полученный результат обратно в луа-интерпретатор.</span></li>
<li class="rvps10"><span class="rvts22">Луа-интерпретатор помещает полученные данные в стек, при необходимости конвертируя их в формат, принимаемый луа-кодом.</span></li>
<li class="rvps10"><span class="rvts22">Функции </span><span class="rvts70">submitinputchange()</span><span class="rvts22">, &nbsp;</span><span class="rvts70">submitinsertframes()</span><span class="rvts22"> и </span><span class="rvts70">submitdeleteframes()</span><span class="rvts22"> не вызывают мгновенное изменение мувика, а только создают запись в массиве отложенных заданий, хранящемся в луа-шлюзе Тасэдитора. Все отложенные задания реализуются при вызове функции </span><span class="rvts70">applyinputchanges()</span><span class="rvts22">. Благодаря этому луа-скрипт может вносить в мувик сразу несколько изменений, создавая только один пункт Журнала Истории.</span></li>
</ul>
<p class="rvps10"><a name="BookmarksBranches"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Закладки и ответвления</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Закладки являются специализированной альтернативой Маркерам. А ответвления служат для хранения нескольких мувиков в одном проекте. Для упрощения создания и навигации по ответвлениям они привязаны к Закладкам, по аналогии с традиционными сохранениями.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">В проекте может храниться не более 10 Закладок. Это ограничение связано с количеством цифровых клавиш на клавиатуре. Также такое ограничение позволяет отображать в окне TAS Editor основную информацию сразу обо всех Закладках, без необходимости скроллинга. Кроме того, многолетний опыт традиционного ТАСинга подтверждает, что такого количества слотов для Закладок вполне достаточно для продуктивного ТАСинга. </span></li>
<li class="rvps10"><span class="rvts22">Закладка может быть установлена на любой кадр мувика. Закладки не исчезают, даже когда мувик усекается. Например, если поставить Закладку на кадр 1200, а затем сделать усечение Ввода после кадра 1000, за пределами мувика останется Закладка, при прыжке на которую мувик автоматически расширится до кадра 1200.</span></li>
<li class="rvps10"><span class="rvts22">В Piano Roll Закладки отображаются иконкой с соответствующей цифрой (номером слота). Закладка, хранящая текущее ответвление мувика, отображается голубой цифрой, остальные Закладки отображаются зелёными цифрами.</span></li>
<li class="rvps10"><span class="rvts22">Закладка устанавливается нажатием соответствующего хоткея (для каждого слота есть отдельный хоткей сохранения) либо щелчком правой кнопки мыши по слоту Закладки. При этом Закладка устанавливается на тот кадр, где в данный момент находится Курсор Проигрывателя. Этот номер кадра запоминается в Закладке, и в дальнейшем можно в любой момент отправить Курсор Проигрывателя на этот кадр, щёлкнув левой кнопкой мыши по слоту Закладки или нажав соответствующий хоткей (для каждого слота есть отдельный хоткей прыжка). "Прыжок на Закладку" не является операцией, так как никаких изменений мувика не происходит.</span></li>
<li class="rvps10"><span class="rvts22">В момент установки Закладки Тасэдитор проверяет, отличаются ли сохраняемые данные от уже содержащихся в этой Закладке данных. Если различий не найдено, операция </span><a class="rvts28" href="Operations.html#Bookmark">Bookmark</a><span class="rvts22"> не производится.</span></li>
<li class="rvps10"><span class="rvts22">Помимо номера кадра в слот устанавливаемой Закладки сохраняются все данные текущего мувика (тип Ввода, Ввод, Горячие Правки, Маркеры). В дальнейшем мувик может быть многократно изменён, но пользователь сможет в любой момент вернуться к состоянию мувика, сохранённому в данной Закладке.</span></li>
<li class="rvps10"><span class="rvts22">В слот устанавливаемой Закладки сохраняется скриншот экрана FCEUX на момент создания Закладки, который позволяет быстро узнавать содержимое Закладки без загрузки её ответвления. А также сохраняется копия одного сэйва из Гринзоны (на закладочном кадре), что позволяет после загрузки ответвления сразу же поставить Курсор Проигрывателя на кадр Закладки.</span></li>
<li class="rvps10"><span class="rvts22">После установки Закладки она становится текущей (отображается голубой цифрой), так как её ответвление более остальных похоже на текущий мувик.</span></li>
<li class="rvps10"><span class="rvts22">При смене текущего мувика на ответвление из Закладки происходит изменение Ввода, поэтому Гринзона усекается, начиная с первого отличающегося кадра. Но благодаря хранящемуся в Закладке сэйву в Гринзону возвращается один сэйв на кадре, где и установлена эта Закладка. Поэтому загрузка Закладки всегда мгновенно перемещает Курсор Проигрывателя на кадр Закладки, в то время как прыжок на Закладку (без изменения мувика) может потребовать добегания.</span></li>
<li class="rvps10"><span class="rvts22">Все операции с Закладками (установка, прыжок, загрузка) производятся после окончания эмуляции текущего кадра, даже если сигнал от пользователя сработает в середине кадра.</span></li>
<li class="rvps10"><span class="rvts22">Для отображения основных Данных закладок используется Список (Listview) без скроллинга, содержащий 10 строк и 3 столбца. при создании нового проекта все 10 Закладок пустые, поэтому второй и третий столбец Списка Закладок будут пустовать.</span></li>
<li class="rvps10"><span class="rvts22">В первом столбце Списка Закладок отображается номер слота, которому соответствует данная строка. Номер отображается как и в Piano Roll – с помощью цифровых иконок зелёного или голубого цвета. Нумерация слотов идёт в таком порядке: 1, 2, 3, 4, 5, 6, 7, 8, 9, 0. Этот порядок нужен, чтобы не нарушать ассоциацию с цифровыми клавишами на клавиатуре, которыми пользователь может контролировать Закладки.</span></li>
<li class="rvps10"><span class="rvts22">Во втором столбце Списка Закладок отображается номер кадра, на который установлена Закладка.</span></li>
<li class="rvps10"><span class="rvts22">В третьем столбце Списка Закладок отображается реальное время установки Закладки.</span></li>
<li class="rvps10"><span class="rvts22">Список Закладок разделяется вертикальной чертой примерно пополам. Левая часть (где располагается первый и второй столбец Списка) ассоциируется с закладочным функционалом Закладок. Правая часть (где располагается третий столбец) ассоциируется с ответвлениями, хранящимися в Закладках. Левая часть отображается более светлым оттенком, правая – более тёмным. Щелчок левой кнопкой мыши по левой половине означает прыжок на Закладку, а щелчок по правой половине – загрузку ответвления.</span></li>
<li class="rvps10"><span class="rvts22">Строки Списка Закладок окрашиваются цветами, соответствующими цветам строк Piano Roll, на которых установлены эти Закладки. Например, если Закладка установлена на кадре 1000, и на этом кадре в данный момент находится Курсор Проигрывателя, то в Списке Закладок строчка этой Закладки будет нарисована голубым цветом. Эта фича даёт пользователю дополнительную информацию о расположении Закладок в мувике.</span></li>
<li class="rvps10"><span class="rvts22">Вместо постоянного просмотра Списка Закладок можно переключать вид на Дерево ответвлений. Переключение осуществляется щелчком по заголовку, расположенному над Списком Закладок.</span></li>
<li class="rvps10"><span class="rvts22">Дерево ответвлений – это графическое представление взаимосвязей между ответвлениями всех Закладок в проекте. Обычно Закладки создаются по мере создания мувика, поэтому более поздние Закладки хранят ответвление, начальная часть которого совпадает с ответвлениями более ранних Закладок. Для каждой Закладки можно найти "родительскую" Закладку, из мувика которой, вероятнее всего, произошёл мувик данной Закладки. В результате все Закладки выстраиваются в иерархическую структуру, в начале которой находится корень (отображается в виде тучки), являющийся родителем Закладок, для которых не нашлось родителя. Поиск родителей для Закладок осуществляется при каждом изменении любой Закладки. При поиске также учитывается номер кадра, на котором установлена каждая Закладка, так что в начале иерархии находятся Закладки с наименьшим номером кадра.</span></li>
<li class="rvps10"><span class="rvts22">Маркеры, содержащиеся в ответвлениях Закладок, не влияют на алгоритм поиска родителей и формирования Дерева. Родитель определяется по Вводу.</span></li>
<li class="rvps10"><span class="rvts22">При установке Закладки она становится текущей, и её содержимое ничем не отличается от текущего мувика. Но после внесения изменений в мувик текущая Закладка уже будет отличаться, поэтому в Дереве ответвлений появляется фаербол, сообщающий об этом. Фаербол символизирует текущий мувик, однако его родителем всегда считается текущая Закладка. Реального поиска лучшего родителя не производится, так как пришлось бы после каждой модификации мувика запускать сравнение его Ввода со всеми Закладками, что признано слишком ресурсоёмким.</span></li>
<li class="rvps10"><span class="rvts22">Закладки в Дереве ответвлений отображаются цифровыми иконками (как и в Piano Roll). Текущая Закладка отображается голубой цифрой. Связи между Закладками отображаются тонкими линиями. Для текущей Закладки формируется последовательность красных линий, связывающих все закладки, при загрузке которых не будет изменения Ввода текущего мувика (потому что как минимум до закладочного кадра загружаемый Ввод будет совпадать с Вводом, хранящимся в текущей Закладке). Эти красные линии идут от тучки к текущей Закладке, либо ещё далее – к наследникам текущей Закладки (когда текущая Закладка содержит тот же самый Ввод, который содержится в этих наследниках).</span></li>
<li class="rvps10"><span class="rvts22">Благодаря расположению Закладок по возрастанию их номера кадра, последовательность красных линий можно воспринимать как хронологию текущего мувика. Началом этой хронологии служит тучка, при щелчке по ней Курсор проигрывателя посылается на начало мувика. Закладки, нанизанные на красную нить, являются промежуточными этапами этой хронологии, при щелчке по ним Курсор Проигрывателя посылается на кадр указанной Закладки. Фаербол (если он есть) считается концом текущей хронологии, и при щелчке по нему Курсор Проигрывателя посылается в конец мувика.</span></li>
<li class="rvps10"><span class="rvts22">Таким образом, любое положения Курсора Проигрывателя можно проецировать на эту хронологическую линию, найдя две Закладки, между кадрами которых располагается Курсор Проигрывателя, и переведя расстояние, измеряемое в кадрах, в пиксели. В результате текущее положение Курсора Проигрывателя постоянно отображается в Дереве ответвлений в виде маленького голубого треугольника (по аналогии с иконкой Курсора Проигрывателя в Piano Roll).</span></li>
<li class="rvps10"><span class="rvts22">Аналогично просмотру текущей хронологии можно быстро увидеть альтернативную хронологию для любой Закладки, наведя на неё курсор мыши (хронология будет отображаться синими линиями).</span></li>
<li class="rvps10"><span class="rvts22">Все данные Закладок сохраняются и загружаются из файла проекта. Для Дерева ответвлений сохраняются и загружаются только кэшированные данные о номере первого кадра различий во Вводе для каждой пары Закладок. Исходя из этих данных Тасэдитор легко восстанавливает иерархию родительских отношений между закладками. А если эти данные отсутствуют, Тасэдитору придётся заново произвести сравнение Ввода всех Закладок относительно друг друга.</span></li>
</ul>
<p class="rvps10"><a name="PopupWindows"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Всплывающие окна</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Служат для показа контекстозависимой информации, которая нужна только в определённые моменты времени.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">В TAS Editor 1.0 реализовано только два вида всплывающих окон: скриншоты к Закладкам и текстовые описания к Закладкам. Оба окна всплывают при наведении курсора мыши либо на правую половину Списка Закладок, либо на любую иконку Закладки в Дереве ответвлений.</span></li>
<li class="rvps10"><span class="rvts22">Оба окна появляются (с полупрозрачностью) в течение примерно полусекунды после наведения курсора мыши на активный элемент. Исчезают так же в течение примерно полусекунды после уведении курсора от элемента.</span></li>
<li class="rvps10"><span class="rvts22">В </span><a class="rvts28" href="ProgramCustomization.html#DisplayBranchScreenshots">настройках</a><span class="rvts22"> можно отключить тот или другой тип всплывающих окон.</span></li>
<li class="rvps10"><span class="rvts22">В окне </span><span class="rvts26">скриншота</span><span class="rvts22"> отображается сохранённая в указанной Закладке копия экрана FCEUX на момент создания Закладки. В зависимости от настройки </span><a class="rvts28" href="ProgramCustomization.html#HUDinBranchscreenshots">HUD in Branch screenshots</a><span class="rvts22"> в Закладку сохраняется либо просто содержимое буфера экрана эмулируемой приставки, либо изображение экрана приставки с наложенными данными эмулятора. Скриншоты служат для быстрой оценки содержимого Закладки, а также для сравнения альтернативных стратегий.</span></li>
<li class="rvps10"><span class="rvts22">В окне </span><span class="rvts26">описания</span><span class="rvts22"> отображается текстовое поле, по ширине равное ширине верхнего и нижнего текстового поля для редактирования Заметок. В поле отображается текст Заметки Маркера, взятого из ответвления указанной Закладки. Маркер определяется номером кадра, на котором установлена эта Закладка.</span></li>
<li class="rvps10"><span class="rvts22">Окно скриншота отображается сбоку от раздела Закладок, окно описания отображается под окном скриншота.</span></li>
<li class="rvps10"><span class="rvts22">При перетаскивании окна TAS Editor всплывающие окна перемещаются вместе с ним.</span></li>
<li class="rvps10"><span class="rvts22">Если во время отображения всплывающих окон меняется содержимое указанной Закладки, содержимое всплывающих окон также мгновенно обновляется.</span></li>
</ul>
<p class="rvps10"><a name="HistoryLog"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Журнал Истории</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Журналирование всех существенных изменений проекта служит, главным образом, для отката этих изменений, а также для визуального отслеживания этой истории.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">В каждом пункте Журнала Истории хранится полная копия текущего Ввода, Лага и Маркеров на момент создания пункта. Также в любом пункте может храниться резервная копия Закладки, если пункт создан из-за операции </span><a class="rvts28" href="Operations.html#Bookmark">Bookmark</a><span class="rvts22">.</span></li>
<li class="rvps10"><span class="rvts22">Данные каждого пункта хранятся в оперативной памяти одновременно в двух видах &nbsp;– сжатом и несжатом. Несжатый используется при работе, сжатый сохраняется в fm3-файл. При создании нового пункта Истории он хранится только в несжатом виде, однако каждые полсекунды Тасэдитор проходится по Журналу Истории и создаёт сжатую версию для первого попавшегося пункта без сжатой версии. Таким образом, к моменту сохранения проекта на диск почти все пункты Истории уже имеют сжатую версию, а те, которые не имеют, сжимаются во время сохранения (что немного замедляет процесс сохранения). При загрузке fm3-файла пункты Журнала Истории загружаются в запакованном виде и распаковываются.</span></li>
<li class="rvps10"><span class="rvts22">Благодаря Журналу Истории реализуется поиск первого изменившегося кадра, после которого затем усекается Гринзона. Большинство </span><a class="rvts28" href="Operations.html">операций</a><span class="rvts22"> работают таким образом:</span></li>
</ul>
<ul style="text-indent: 30px; margin-left: 40px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Вносятся изменения в данные текущего мувика.</span></li>
<li class="rvps10"><span class="rvts22">Запоминаются минимальный и максимальный номер кадра, в который были внесены изменения.</span></li>
<li class="rvps10"><span class="rvts22">Вызывается регистрация изменений с помощью Истории, минимальный и максимальный кадр передаются в качестве параметров вместе с кодом операции и другими параметрами.</span></li>
</ul>
<ul style="text-indent: 30px; margin-left: 70px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">История сверяет содержимое текущего мувика с содержимым последнего пункта Журнала Истории. Если задан минимальный кадр, то сверка начинается с этого кадра, игнорируя содержимое мувика до него (ради ускорения работы). Иначе проверяется всё от начала мувика. Если задан максимальный кадр, то сверка заканчивается после этого кадра (но большинство операций не передают максимальный кадр, так как, например, вставка пустого кадра передвигает весь последующий Ввод, и нужно вести проверку до самого конца мувика).</span></li>
<li class="rvps10"><span class="rvts22">Как только обнаруживается первое различие между Вводом/Маркерами мувика и Вводом/Маркерами последнего снимка мувика, создаётся новый пункт в Журнале Истории и заполняются все его атрибуты.</span></li>
<li class="rvps10"><span class="rvts22">Если различия не были обнаружены, то считается, что операция не повлияла на мувик, и никакие изменения в проекте не регистрируются. Например, если записать те же самые нажатия поверх уже имеющихся, операция </span><a class="rvts28" href="Operations.html#Record">Record</a><span class="rvts22"> не будет зарегистрирована.</span></li>
<li class="rvps10"><span class="rvts22">Даже если операция не повлияла на Ввод/Маркеры, она могла сдвинуть Лаг, так что История также сравнивает Журналы лага и возвращает кадр первого различия.</span></li>
<li class="rvps10"><span class="rvts22">Для операции </span><a class="rvts28" href="Operations.html#Record">Record</a><span class="rvts22"> регистрируется не только номер кадра с изменившимся Вводом, но и номер джойстика, кнопки которого были изменены.</span></li>
<li class="rvps10"><span class="rvts22">Последовательно добавляемые пункты для операций </span><a class="rvts28" href="Operations.html#AdjustLag">AdjustLag</a><span class="rvts22">, </span><a class="rvts28" href="Operations.html#Record">Record</a><span class="rvts22">, </span><a class="rvts28" href="Operations.html#Set">Set</a><span class="rvts22"> или </span><a class="rvts28" href="Operations.html#Unset">Unset</a><span class="rvts22"> могут объединяться в один пункт Журнала Истории, чтобы их было удобнее откатывать в случае необходимости. Объединение производится во время заполнения атрибутов нового пункта Журнала Истории. Вместо добавления этого пункта в конец Журнала происходит замена последнего пункта на новый.</span></li>
<li class="rvps10"><span class="rvts22">После регистрации нового пункта История подаёт сигнал Дереву ответвлений (чтобы на нём появился фаербол) и менеджеру проекта (чтобы в заголовке окна появилась звёздочка), а затем возвращает номер кадра, на котором были обнаружено первое различие. Если различий не было найдено, возвращается -1.</span></li>
</ul>
<ul style="text-indent: 30px; margin-left: 40px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Вызывается усечение Гринзоны после кадра с первым обнаруженным различием. Этот номер может быть больше, чем минимальный номер кадра, в который были внесены изменения самой операцией. Например, если установить нажатия кнопки на всех выделенных кадрах, минимальным номером кадра будет первый выделенный кадр, но Гринзона будет усечена только после того выделенного кадра, на котором раньше не было нажатия этой кнопки.</span></li>
</ul>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Откат Истории осуществляется как переход с текущего пункта Журнала Истории на предыдущий. Можно напрямую прыгать на любой пункт Журнала Истории. Текущий мувик и текущие Маркеры восстанавливаются из данных, содержащихся в этом пункте, а сам пункт становится текущим.</span></li>
<li class="rvps10"><span class="rvts22">Одним из атрибутов каждого пункта Истории является "номер ключевого кадра". Для большинства операций это номер кадра, где обнаружилось первое различие. Для операций, сдвигающих Ввод, это номер минимального кадра.</span></li>
<li class="rvps10"><span class="rvts22">При прыжках по Истории в Piano Roll на полсекунды появляется курсор-указка фиолетового цвета, акцентирующий внимание на ключевом кадре. При откате (undo) этот курсор указывает на ключевой кадр следующего пункта Истории (относительно текущего), при повторе (redo) этот курсор указывает на ключевой кадр текущего пункта истории.</span></li>
</ul>
<p class="rvps10"><a name="RerecordsCounter"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Счётчик перезаписей</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">По традиции во всех ТАСерских эмуляторах ведётся учёт количества перезаписей, использованных во время создания ТАСа. Это число может использоваться для примерной оценки трудозатрат.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Счётчик перезаписей хранится в мувике (а значит и в fm3-файле проекта). При создании нового мувика (либо нового проекта в Тасэдиторе) счётчик обнуляется.</span></li>
<li class="rvps10"><span class="rvts37">При ТАСинге вне Тасэдитора:</span><span class="rvts22"> счётчик увеличивается на единицу каждый раз, когда ТАСер загружает сэйв в режиме Записи, чтобы изменить Ввод на уже просмотренном участке мувика. Счётчик не увеличивается, когда ТАСер записывает Ввод для кадров, события которых ему не известны.</span></li>
<li class="rvps10"><span class="rvts37">При ТАСинге в Тасэдиторе:</span><span class="rvts22"> счётчик увеличивается на единицу каждый раз, когда ТАСер изменяет Ввод на отгринзоненном участке мувика. Счётчик не увеличивается, когда ТАСер изменяет Ввод для кадров, находящихся дальше головы Гринзоны.</span></li>
<li class="rvps10"><span class="rvts22">Таким образом, в обоих случаях ведётся учёт, </span><span class="rvts37">сколько раз ТАСер изменил известное ему будущее</span><span class="rvts22">. Счётчик не увеличивается, когда ТАСер меняет будущее вслепую, то есть до просмотра игровых событий на изменяемых кадрах.</span></li>
<li class="rvps10"><span class="rvts22">В старых эмуляторах счётчик увеличивается прямо в момент загрузки сэйва в режиме Записи, ещё до того, как ТАСер изменяет Ввод. Из-за этого возможна ситуация, когда пользователь несколько раз подряд нажимает хоткей загрузки сэйва (например, </span><span class="rvts27">F1</span><span class="rvts22">), и при каждом нажатии счётчик перезаписей будет увеличиваться. В Тасэдиторе счётчик увеличивается только в момент усечения Гринзоны, независимо от выбранного способа навигации. Поэтому при первом нажатии </span><span class="rvts27">F1</span><span class="rvts22"> счётчик увеличится только в случае, если ответвление этой Закладки отличается от текущего мувика, причём расхождение должно начинаться с отгринзоненного кадра. А при повторных нажатиях </span><span class="rvts27">F1</span><span class="rvts22"> счётчик не будет увеличиваться, так как ответвление Закладки уже не отличается от текущего мувика, и изменения Ввода не происходит.</span></li>
</ul>
<p class="rvps10"><a name="Modifiers"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Система клавиш-модификаторов</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Для повышения интуитивности клавиатурного управления в Тасэдиторе используется строгое разделение функций клавиш модификаторов:</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts34">Shift</span><span class="rvts22"> ассоциируется с </span><a class="rvts28" href="Glossary.html#Output">Выводом</a><span class="rvts22"> мувика, а конкретно с Курсором Проигрывателя. Клавиатурные комбинации, содержащие эту клавишу, обычно управляют этим курсором. Если быстро нажать </span><span class="rvts34">Shift </span><span class="rvts22">два раза подряд, Piano Roll автоматически скроллируется к Курсору Проигрывателя.</span></li>
<li class="rvps10"><span class="rvts34">Ctrl</span><span class="rvts22"> ассоциируется с </span><a class="rvts28" href="Glossary.html#Input">Вводом</a><span class="rvts22"> мувика, а конкретно &nbsp;с Курсором Выделения. Многие клавиатурные комбинации, содержащие эту клавишу, относятся к управлению этим курсором. Если быстро нажать </span><span class="rvts34">Ctrl </span><span class="rvts22">два раза подряд, Piano Roll автоматически скроллируется к Курсору Выделения.</span></li>
<li class="rvps10"><span class="rvts34">Alt</span><span class="rvts22"> ассоциируется с шаблонами и чередующимися последовательностями, в частности, с промежутками в этих последовательностях.</span></li>
</ul>
<p class="rvps10"><a name="Patterns"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Шаблоны</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Заготовленные последовательности состояний для одной кнопки. Подробнее см. </span><a class="rvts28" href="AdvancedFeatures.html#UsingPatterns">Продвинутые возможности</a><span class="rvts22">.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Шаблоны &nbsp;хранятся во внешнем текстовом файле в формате, доступном для редактирования в Блокноте. Формат файла должен быть описан в самом файле.</span></li>
<li class="rvps10"><span class="rvts22">Каждый шаблон должен иметь имя, которое будет отображаться в списке шаблонов.</span></li>
<li class="rvps10"><span class="rvts22">Шаблоны загружаются из файла в оперативную память в момент открытия окна TAS Editor.</span></li>
<li class="rvps10"><span class="rvts22">В TAS Editor 1.0 нет встроенных средств редактирования шаблонов, так как формат очень прост, а фича не слишком востребована.</span></li>
<li class="rvps10"><span class="rvts22">По шаблону можно устанавливать Ввод, Маркеры и даже Выделение.</span></li>
<li class="rvps10"><span class="rvts22">При установке шаблона может учитываться или не учитываться лаг. Подробнее: </span><a class="rvts28" href="ProgramCustomization.html#AutofirePatternskipsLag">Настройка программы</a></li>
</ul>
<p class="rvps10"><a name="CrossingGaps"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Пересечение промежутков</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Дополнительный способ быстрой навигации по содержимому Piano Roll, облегчающий визуальное прослеживание длинных последовательностей для отдельно взятой кнопки или Маркеров. Также он позволяет переходить от одной Закладки к другой.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Пересечение промежутков – это вертикальный скроллинг Piano Roll, срабатывающий при вращении колеса мыши с зажатой клавишей </span><span class="rvts34">Alt</span><span class="rvts22">. Конкретная величина скроллинга не зависит от скорости вращения колеса, а рассчитывается каждый раз индивидуально, исходя из состояния ячейки Piano Roll рядом с курсором мыши. Так что имеет значение только направление вращения колеса (вверх или вниз).</span></li>
<li class="rvps10"><span class="rvts22">Пересечение &nbsp;промежутков подразумевает, что пользователь хочет найти ячейку, находящуюся на расстоянии более одного кадра от ячейки под курсором мыши (иначе нет смысла использовать эту функцию, достаточно просто провести курсор мыши чуть выше).</span></li>
<li class="rvps10"><span class="rvts22">Таким образом, при вращении колеса мыши вверх эта функция запоминает значение ячейки, предшествующей ячейке под курсором мыши. Затем функция начинает поиск ячейки, значение которой не совпадает с данным значением. Поиск идёт снизу вверх от ячейки, предшествующей ячейке под курсором мыши. При успешном обнаружении такой ячейки Piano Roll скроллируется таким образом, чтобы курсор мыши теперь указывал на найденную ячейку. Если же поиск дошёл до начала мувика, а ячейка не найдена, то Piano Roll не скроллируется.</span></li>
<li class="rvps10"><span class="rvts22">Аналогично при вращении колеса мыши вниз эта функция запоминает значение ячейки, следующей за ячейкой под курсором мыши. Затем функция начинает поиск ячейки, значение которой не совпадает с данным значением. Поиск идёт сверху вниз от ячейки, следующей за ячейкой под курсором мыши.</span></li>
<li class="rvps10"><span class="rvts22">Запоминаемое значение имеет булев тип. То есть, например, все иконки имеют одинаковое значение (true), и все пустоты – тоже одинаковое (false).</span></li>
</ul>
<p class="rvps10"><a name="SaveCompact"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Компактное сохранение</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Файл проекта Тасэдитора в первую очередь предназначен для сохранения точного снимка рабочего процесса. Чтобы использовать тот же самый формат для обмена файлами, необходимо предоставить пользователю возможность избирательного сохранения рабочих данных в файл. При открытии такого fm3-файла отсутствующие данные будут заменяться данными по умолчанию.</span></p>
<p class="rvps10"><span class="rvts22">Подробнее см. </span><a class="rvts28" href="AdvancedFeatures.html#ProjectsSharing">Продвинутые возможности</a><span class="rvts22"> и </span><a class="rvts28" href="FM3format.html">Формат FM3</a><span class="rvts22">.</span></p>
<p class="rvps10"><a name="Autosave"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Автосохранение</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Как и в случае с любым офисным документом, проект Тасэдитора желательно время от времени сохранять на диск, даже если не планируется выход из программы. Однако до Тасэдитора у ТАСеров не было такой привычки, поэтому имеет смысл сохранять проект автоматически, предоставив пользователю возможность настроить или отключить эту функцию.</span></p>
<p class="rvps10"><span class="rvts22">Подробнее см. </span><a class="rvts28" href="ProgramCustomization.html#Projectfilesavingoptions">Настройка программы</a><span class="rvts22">.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<hr style="height: 1px; color : #000000;  background-color : #000000; border-width : 0px;"/>
<p class="rvps10"><a name="PlannedIdeas"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts75">Запланированные идеи</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><a name="OutputLog"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Журнал Вывода</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Следующий этап эволюции инструмента Memory Watch – просмотр состояния игровых данных в динамике, а не только в статике. Аналогично Журналу лага, эта фича позволит легче и точнее анализировать принципы изменения игрового Вывода.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Список (ListView), вертикальный скроллинг которого синхронизирован со скроллингом Piano Roll. Высота списка равна высоте Piano Roll, количество строк также всегда равно количеству строк Piano Roll. Количество колонок Списка зависит от нужд пользователя.</span></li>
<li class="rvps10"><span class="rvts22">Можно гибко измененять ширину Списка (перетаскиванием узкой границы между ним и Piano Roll, соответственно изменяется ширина Piano Roll, таким образом их суммарная ширина всегда остаётся одинаковой). Можно также менять Список и Piano Roll местами, либо полностью отключать отображение Журнала Вывода. При отключении отображения Журнала Piano Roll расширяется на освобождённое пространство, в точности как в TAS Editor 1.0. Отключение отображения Журнала не означает отключение журналирования данных.</span></li>
<li class="rvps10"><span class="rvts22">В Заголовке Списка отображаются названия журналируемых ячеек. Можно добавлять и удалять колонки, изменять названия, менять колонки местами и изменять их ширину. При создании нового проекта ни одной колонки в Журнале Вывода нет, и, соответственно, журналирование не ведётся.</span></li>
<li class="rvps10"><span class="rvts22">В строках списка отображаются значения ячеек, сохранённые из состояния игры на соответствующем кадре мувика. Строки Списка раскрашиваются теми же цветами, что и соответствующие строки Piano Roll. При выделении строк в Piano Roll выделяются строки в Журнале.</span></li>
<li class="rvps10"><span class="rvts22">Помимо ячеек RAM необходимо реализовать журналирование переменных Lua. Например, предоставить Lua-скриптам Read/Write-доступ к дюжине int-переменных Тасэдитора и дать пользователю возможность журналировать любые ячейки из этой дюжины.</span></li>
<li class="rvps10"><span class="rvts22">Кроме того, в будущем можно реализовать добавление колонки со скриншотами игры (либо выбранной прямоугольной областью игрового экрана). Причём отображаемый размер скриншота будет зависеть от текущей ширины колонки, и как следствие, скриншоты будут отображаться не на каждой строчке Журнала, а через каждые несколько строк. Однако съёмка скриншотов всегда осуществляется на каждом кадре.</span></li>
<li class="rvps10"><span class="rvts22">Все журналируемые данные хранятся в Гринзоне, наравне с Журналом лага. При добавлении ячейки RAM возможно автоматическое заполнение всей колонки (Тасэдитор пробегает по всем сэйвам Гринзоны, распаковывает их и берёт значение из сохранённой копии RAM). При добавлении переменной Lua значения ячеек будут неопределёнными (пустые ячейки в Списке), и для их заполнения пользователю необходимо будет заново проэмулировать мувик с запущенным Lua-скриптом.</span></li>
<li class="rvps10"><span class="rvts22">При усечении Гринзоны старые данные, ставшие неактуальными, не удаляются, но отображаются менее ярким цветом, пока на их место не будут записаны новые данные. При удалении сэйвов из хвоста Гринзоны данные Журнала остаются и отображаются обычным цветом.</span></li>
<li class="rvps10"><span class="rvts22">Возможна гибкая расцветка ячеек, например, подсветка одинаковых значений в Выделении, подсветка искомых значений, автоматическое изменение цвета при изменении значения, автоматическая индикация при достижении заданного значения и т.д.</span></li>
<li class="rvps10"><span class="rvts22">Возможно чтение любых данных Гринзоны из Lua-скриптов с помощью API Тасэдитора.</span></li>
<li class="rvps10"><span class="rvts22">Акселераторы </span><span class="rvts34">Shift + Вправо</span><span class="rvts22"> / </span><span class="rvts34">Shift + Влево</span><span class="rvts22"> теперь будут горизонтально скроллировать не Piano Roll, а Список Журнала. Скроллинг осуществляется по целым колонкам.</span></li>
<li class="rvps10"><span class="rvts22">Необходимо также реализовать новые методы навигации по мувику в зависимости от значения ячеек. Например, с помощью </span><span class="rvts34">Alt</span><span class="rvts22"> и вращения колеса можно пересекать промежутки в Списке для поиска ближайшего неравного или, наоборот, равного значения.</span></li>
</ul>
<p class="rvps10"><a name="Minimap"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Миникарта</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Графически отображает в окне Тасэдитора весь мувик – Гринзону, лаг, Курсор Проигрывателя, Выделение, Маркеры, Закладки, точки Горячих Правок, подсветку Журнала Вывода и т.д. Предоставляет пользователю мгновенный образ текущего проекта, не обладающий детальностью, зато полностью умещающийся на экране. Также усовершенствует навигацию.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Миникарта представляет собой прямоугольный bitmap-холст, по высоте равный высоте Piano Roll, по ширине равный 30 пикселей (плюс ещё 10 на иконки Закладок). Может располагаться слева или справа от Piano Roll и Журнала Вывода.</span></li>
<li class="rvps10"><span class="rvts22">В пункте меню "View" можно гибко настраивать отображаемые элементы на миникарте (устанавливать галочки напротив желаемых элементов). Также можно совсем отключить отображение Миникарты.</span></li>
<li class="rvps10"><span class="rvts22">Миникарта не хранит какие-либо данные проекта. Она втоматически перерисовывается с заданной периодичностью (по умолчанию раз в секунду).</span></li>
<li class="rvps10"><span class="rvts22">Маркеры отображаются горизонтальными линиями жёлтого цвета на левой половине Миникарты. Каждая такая линия занимает по высоте как минимум 1 пиксель, поэтому Маркеры не теряются даже при мелком масштабе Миникарты (когда в мувике намного больше кадров, чем высота Миникарты в пикселях). Ширина линии равна 9px.</span></li>
<li class="rvps10"><span class="rvts22">Горячие Правки отображаются горизонтальными линиями соответствующего цвета на правой половине Миникарты. Каждая такая линия занимает по высоте как минимум 1 пиксель. Ширина линии равна 9px.</span></li>
<li class="rvps10"><span class="rvts22">Закладки отображаются соответствующими иконками слева от Миникарты. По этим иконкам можно щёлкать левой и правой кнопкой мыши, эффект будет аналогичен щелчкам по иконкам в Дереве Ответвлений.</span></li>
<li class="rvps10"><span class="rvts22">При наведении курсора мыши на миникарту в этой области появляется прямоугольная лупа.</span></li>
<li class="rvps10"><span class="rvts22">Щелчок левой кнопкой мыши по миникарте – мгновенный скроллинг видимой области Piano Roll к указанному месту в мувике. Далее можно перетаскивать видимую область вверх/вниз по мувику, не отпуская левую кнопку.</span></li>
<li class="rvps10"><span class="rvts34">Shift</span><span class="rvts22"> + щелчок левой кнопкой, или просто щелчок правой кнопкой мыши по миникарте – навигация Курсором Проигрывателя. Далее можно перетаскивать Курсор Проигрывателя, не отпуская правую кнопку.</span></li>
</ul>
<p class="rvps10"><a name="VirtualJoypad"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Виртуальный Джойстик</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Альтернативный способ ввода инпута. Очень похож на изменение инпута щелчками по Заголовку Piano Roll, однако более нагляден и интуитивен.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Виртуальный Джойстик представляет собой всплывающее немодальное окно с изменяемыми размерами. Содержимое окна автоматически масштабируется при изменении размеров окна.</span></li>
<li class="rvps10"><span class="rvts22">Окно Виртуального Джойстика появляется под курсором мыши при щелчке правой кнопкой в Piano Roll по выделенному Вводу или Вводу под Курсором Проигрывателя. В настройках пользователь может отключить появление Виртуального Джойстика под курсором при правом щелчке. Тогда можно оставить это окно в удобном месте рабочего стола и при необходимости перемещать курсор мыши то к нему, то обратно к Piano Roll.</span></li>
<li class="rvps10"><span class="rvts22">По цвету фона окна можно определить, отображает ли Виртуальный Джойстик состояние Ввода в Выделении (синий фон) или под Курсором Проигрывателя (голубой фон).</span></li>
<li class="rvps10"><span class="rvts22">При уведении курсора мыши за пределы окна Виртуального Джойстика это окно либо автоматически скрывается (если установлена настройка "Hide on mouse leave"), либо остаётся на месте.</span></li>
<li class="rvps10"><span class="rvts22">При нажатии левой кнопкой мыши над неактивными областями начинается перетаскивание окна.</span></li>
<li class="rvps10"><span class="rvts22">При нажатии правой кнопкой мыши в любом месте окна окно скрывается.</span></li>
<li class="rvps10"><span class="rvts22">В окне расположены управляющие элементы – кнопки, соответствующие кнопкам реального джойстика эмулируемой приставки. Расположение кнопок соответствует реальному прототипу. По внешнему виду кнопок можно определить, являются ли соответствующая кнопка в Выделении нажатой, отпущенной или частично нажатой (это когда выделено более одного кадра).</span></li>
<li class="rvps10"><span class="rvts22">Содержимое окна автоматически обновляется при каждом изменении Ввода, а также при изменении Выделения, если Виртуальный Джойстик показывает Ввод в Выделении.</span></li>
<li class="rvps10"><span class="rvts22">Виртуальный Джойстик отражает состояние только одного джойстика – текущего джойстика, выбранного радиокнопкой в разделе Recorder.</span></li>
<li class="rvps10"><span class="rvts22">При щелчке по кнопке происходит изменение Ввода текущего джойстика. Нажатая кнопка становится отпущенной, а отпущенная или частично нажатая становится нажатой. Соответственно меняется Ввод во всех выделенных кадрах или на кадре Курсора Проигрывателя.</span></li>
<li class="rvps10"><span class="rvts22">В дополнение к нормальным кнопкам Ввода в окне Виртуального Джойстика можно разместить несколько макро-кнопок. Щелчок по кнопке Макроса будет аналогичен нескольким щелчкам по нормальным кнопкам. Это позволит ещё быстрее менять Ввод в Выделении, например, вместо трёх щелчков по кнопкам </span><span class="rvts32">Вверх</span><span class="rvts22">, </span><span class="rvts32">Вправо</span><span class="rvts22"> и </span><span class="rvts32">B</span><span class="rvts22"> можно будет сделать один щелчок по </span><span class="rvts74">Макросу1</span><span class="rvts22">.</span></li>
<li class="rvps10"><span class="rvts22">Если перед щелчком по кнопке Виртуального Джойстика или кнопке макроса зажать клавишу </span><span class="rvts34">Alt</span><span class="rvts22">, будет установлен Ввод по шаблону.</span></li>
<li class="rvps10"><span class="rvts22">После реализации Виртуального Джойстика можно изменить принцип действия щелчков по Заголовку Piano Roll. Теперь вместо изменения инпута щелчки по Заголовку будут выделять соответствующие столбцы Piano Roll.</span></li>
</ul>
<p class="rvps10"><a name="BetterSelection"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Усовершенствование Выделения</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Архитектура TAS Editor 1.0 не рассчитана на выделение столбцов Piano Roll, однако в некоторых ситуациях это может быть полезно при ТАСинге. Например, для очистки Ввода первого джойстика без очистки Ввода второго джойстика. Либо для перемещения Ввода одной кнопки без смещения остальных внопок.</span></p>
<p class="rvps10"><span class="rvts22">Кроме того, необходимо усовершенствовать процесс рисования Выделения, чтобы пользователь мог видеть цвет строк Piano Roll под полупрозрачным Выделением.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Выделение столбцов производится аналогично выделению строк – при щелчке левой кнопкой мыши по Заголовку Piano Roll соответствующий столбец становится выделенным, а все остальные столбцы перестают выть выделенными. Если перед щелчком зажать клавишу </span><span class="rvts34">Ctrl</span><span class="rvts22">, выделение остальных столбцов не исчезнет. Если зажать </span><span class="rvts34">Shift</span><span class="rvts22">, будет выделен регион столбцов от места предыдущего щелчка. Если зажать </span><span class="rvts34">Alt</span><span class="rvts22">, выделится регион по шаблону. После щелчка можно не отпускать левую кнопку и растягивать Выделение по горизонтали.</span></li>
<li class="rvps10"><span class="rvts22">Выделять можно только столбцы Ввода. Маркеры же зависят от настройки "Bind markers to Input".</span></li>
<li class="rvps10"><span class="rvts22">Выделенные столбцы отмечаются в Заголовке синим фоном в соответствующих ячейках.</span></li>
<li class="rvps10"><span class="rvts22">Отсутствие выделенных столбцов равносильно состоянию "выделены все столбцы".</span></li>
<li class="rvps10"><span class="rvts22">При отображении строк Выделения ячейки Ввода из невыделенных столбцов рисуются с альфой ~0.4, в то время как ячейки из выделенных столбцов имеют альфу ~0.7.</span></li>
<li class="rvps10"><span class="rvts22">В колонке с номерами кадров выделенные строки имеют альфу ~0.4, когда Маркеры отвязаны, и ~0.7, когда Маркеры привязаны.</span></li>
<li class="rvps10"><span class="rvts22">В разделе Splicer отображается не только количество выделенных строк (rows), но и количество выделенных столбцов (columns).</span></li>
<li class="rvps10"><span class="rvts22">При копировании в Буфер Обмена попадает только Ввод из выделенных столбцов, причём он попадает в виде прямоугольной таблицы, без пропусков между столбцами. Благодаря этому можно изменить выделенные столбцы и вставить Ввод одних кнопок на место других кнопок.</span></li>
<li class="rvps10"><span class="rvts22">При инициализации объекта SELECTION (то есть при запуске Тасэдитора или создании проекта) Выделение сбрасывается в состояние "отсутствует выделение столбцов".</span></li>
<li class="rvps10"><span class="rvts22">При изменении порядка следования столбцов или скрытии/раскрытии столбцоа Выделение сбрасывается в состояние "отсутствует выделение столбцов".</span></li>
<li class="rvps10"><span class="rvts22">При Записи Ввод фильтруется в соответствии с выделением столбцов. Невыделенные столбцы не будут изменяться, даже если пользователь записывает другое состояние кнопки этого столбца.</span></li>
<li class="rvps10"><span class="rvts22">Выделение столбцов также сохраняется в файле проекта.</span></li>
<li class="rvps10"><span class="rvts22">На Историю Выделений это нововведение никак не влияет. Изменение выделения столбцов не сохраняется в Истории Выделений, так как навигация по истории изменения выделения столбцов не требуется.</span></li>
</ul>
<p class="rvps10"><a name="BetterColumns"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Гибкая настройка колонок</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">В TAS Editor 1.0 столбцы Piano Roll имеют фиксированную ширину. Количество и порядок следования столбцов также фиксированы. Для команд приставки (сброс, вставка диска и т.д.) отдельные столбцы не отводятся, так как эти команды используются крайне редко. Однако при портировании Тасэдитора на другие эмуляторы количество столбцов будет возрастать (например, у PSX нужно отображать столбцы для 14 кнопок), необходимо предоставить пользователю возможность настраивать их.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Так как подобная настройка обычно производится только один раз при первом запуске программы, она не обязательно должна осуществляться средствами Piano Roll, можно и в отдельном окне, вызываемом из меню "Config".</span></li>
<li class="rvps10"><span class="rvts22">Возможность отображать любые колонки Ввода, в том числе колонки команд.</span></li>
<li class="rvps10"><span class="rvts22">Возможность прятать любые колонки. Однако от каждого джойстика должна оставаться отображаемой как минимум одна колонка (но если пользователь настроил проект на режим 1P, то колонки второго джойстика в любом случае не будут отображаться).</span></li>
<li class="rvps10"><span class="rvts22">Возможность изменять порядок следования колонок.</span></li>
<li class="rvps10"><span class="rvts22">При копировании в Буфер Обмена копируются только абстрактные значения вида true/false. Поэтому если после копирования изменить порядок следования столбцов и вставить Ввод из Буфера Обмена на то же место, реальный Ввод мувика может измениться (кнопки изменённых столбцов поменяются местами).</span></li>
<li class="rvps10"><span class="rvts22">Возможность изменять ширину колонок. Для платформ с множеством кнопок (например, ПК) полезно уменьшить ширину колонок до нескольких пикселей, чтобы уместить много колонок на экране.</span></li>
<li class="rvps10"><span class="rvts22">Возможность одним щелчком восстановить значения по умолчанию (рекомендуемые автором).</span></li>
<li class="rvps10"><span class="rvts22">Все настройки сохраняются в config.</span></li>
</ul>
<p class="rvps10"><a name="RerecordsHeatmap"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Теплокарта перезаписей</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Хранит и отображает статистику "изменений после просмотра" (перезаписей). Может быть полезна для выявления сложных мест в мувике.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Хранит массив int, по одному элементу на каждый кадр мувика (в том числе за пределами Ввода). Значение элемента соответствует количеству усечений Гринзоны на данном кадре.</span></li>
<li class="rvps10"><span class="rvts22">Сохраняет и загружает свои данные из файла проекта.</span></li>
<li class="rvps10"><span class="rvts22">В качестве холста следует использовать холст Миникарты. При ТАСинге не имеет смысла постоянно видеть Теплокарту, пользователь может изредка (например, в конце каждого дня) переключать Миникарту в режим отображения Теплокарты и оценивать проделанный труд.</span></li>
<li class="rvps10"><span class="rvts22">Так как эта фича несёт не столько рабочую, сколько эстетическую функцию, необходимо продумать алгоритм рисования телокарты, чтобы было не только информативно, но и красиво.</span></li>
</ul>
<p class="rvps10"><a name="Etc"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Прочие мелочи</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Отдельный Журнал Истории для операций </span><a class="rvts28" href="Operations.html#Bookmark">Bookmark Set</a><span class="rvts22"> (</span><span class="rvts34">Alt + Z</span><span class="rvts22"> и </span><span class="rvts34">Alt + Y</span><span class="rvts22">), для отката изменений Ввода/Маркеров без отката изменений Закладок, и наоборот.</span></li>
<li class="rvps10"><span class="rvts22">Возможность работать с </span><span class="rvts22">мувиками, начинающимися с сэйва.</span></li>
<li class="rvps10"><span class="rvts22">Возможность работать с несколькими эмулируемыми играми одновременно (для Multi-TAS-проектов).</span></li>
<li class="rvps10"><span class="rvts22">Усовершенствование Lua API.</span></li>
<li class="rvps10"><span class="rvts22">Поддержка мультитач-управления.</span></li>
<li class="rvps10"><span class="rvts22">Продумать концепцию заполнения Гринзоны в фоне (насколько она соответствует особенностям ТАСинга).</span></li>
</ul>
<p class="rvps10"><a name="OtherPlatforms"></a>
<span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts23">Поддержка платформ, отличных от NES</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22">Если Тасэдитор приобретёт популярность среди ТАСеров, необходимо расширить его доступность для всех эмулируемых платформ.</span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<ul style="text-indent: 30px; margin-left: 0px; list-style-position: inside;">
<li class="rvps10"><span class="rvts22">Продумать управляющие элементы для отображения и изменения аналогового Ввода в Piano Roll. Виртуальный Джойстик отчасти решает эту проблемы, однако должна быть возможность быстро и легко рисовать аналоговый Ввод мышкой. Например, растягивать на много кадров однократно установленное значение наклона стика, запоминать значение только что очищенной ячейки и предлагать его при рисовании. В ячейке отображается не один символ, а число от -1.0 до +1.0. При двойном щелчке по клетке можно набрать с клавиатуры точное значение этого числа. С зажатым </span><span class="rvts34">Ctrl</span><span class="rvts22"> можно растягивать значение ячейки левой кнопкой мыши вправо/влево или вверх/вниз. В столбце отображается значение наклона только по одной координатной оси (таким образом, для аналогового стика требуется две колонки Piano Roll).</span></li>
<li class="rvps10"><span class="rvts22">В Виртуальном Джойстике должна быть возможность рисовать огибающую для региона кадров, а не только устанавливать одинаковое значение для всех выделенных кадров. Также необходимо переработать формат Шаблонов, чтобы они могли представлять последовательности значений уровня, в том числе с относительными значениями (например, возрастание по параболе, где начальное и конечное значение берётся из начального и конечного кадра выделенного региона).</span></li>
<li class="rvps10"><span class="rvts22">Крайне желателен переход на 64-разрядную платформу, так как объёмы Гринзоны значительно возрастут при хранении сэйвов более продвинутых приставок, и 2GB оперативной памяти для Тасэдитора 2.0 будет недостаточно.</span></li>
</ul>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p class="rvps10"><span class="rvts22"><br/></span></p>
<p></p>
<p class="rvps8"><span class="rvts18">Created with the Personal Edition of HelpNDoc: </span><a class="rvts19" href="http://www.helpndoc.com/feature-tour/create-ebooks-for-amazon-kindle">Produce Kindle eBooks easily</a></p>
</div>
	
	<div id="topic_footer">

			<div id="topic_footer_content">
				&copy; 2011-2013 АнС</div>
		</div>
	</body>
	
</html>

